<!DOCTYPE html><html><head><meta charset=utf-8>
<style>
body{background:#99f}
canvas{position:absolute;top:0;left:0;cursor:none}</style>
<script src="js/three.min.js"></script>
<script>

/** @type {boolean} true/false : 1st/3rd person camera mode. */
var isCameraFirstPerson = false;

var thirdPersonCameraDistance = 5;

/** @type {Object} The player */
var player = {
    model : {       
        objects : new THREE.Object3D(),
        motion  : 'stand',
        state   : 'stand'
    },
    position: {
        x : 0,
        y : 0,
        z : 0,
        direction : 0
    },
    camera : {
        speed : 300,
        distance : thirdPersonCameraDistance,
        x : 0,
        y : 0,
        z : 0
    }
}

/** @type {Object} The universe time */
var clock;

/** @type {number} Window's width in pixel */
var width;

/** @type {number} Window's height in pixel */
var height;

/** @type {Object} The scene with physics */
var scene;

/** @type {Object} The renderer engine */
var renderer;

/** @type {number} Conversion ratio from degrees to radians */
var deg2rad = Math.PI / 180;

var keyboard = {
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    q: 81,
    s: 83,
    z: 90,
};

var moveState = {
    moving    : false,
    front     : false,
    Backwards : false,
    left      : false,
    right     : false,
    speed     : .1,
    angle     : 0
}

var camera, timer, loader, material;

var md2meshBody;

var md2frames = {
        // first, last, fps
        stand   : [  0,  39,  9, {state: 'stand', action: false}],
        run     : [ 40,  45, 10, {state: 'stand', action: false}],
        attack  : [ 46,  53, 10, {state: 'stand', action: true}],
        pain1   : [ 54,  57,  7, {state: 'stand', action: true}],
        pain2   : [ 58,  61,  7, {state: 'stand', action: true}],
        pain3   : [ 62,  65,  7, {state: 'stand', action: true}],
        jump    : [ 66,  71,  7, {state: 'stand', action: true}],
        flip    : [ 72,  83,  7, {state: 'stand', action: true}],
        salute  : [ 84,  94,  7, {state: 'stand', action: true}],
        taunt   : [ 95, 111, 10, {state: 'stand', action: true}],
        wave    : [112, 122,  7, {state: 'stand', action: true}],
        point   : [123, 134,  6, {state: 'stand', action: true}],
        crstand : [135, 153, 10, {state: 'crstand', action: false}],
        crwalk  : [154, 159,  7, {state: 'crstand', action: false}],
        crattack: [160, 168, 10, {state: 'crstand', action: true}],
        crpain  : [196, 172,  7, {state: 'crstand', action: true}],
        crdeath : [173, 177,  5, {state: 'freeze', action: true}],
        death1  : [178, 183,  7, {state: 'freeze', action: true}],
        death2  : [184, 189,  7, {state: 'freeze', action: true}],
        death3  : [190, 197,  7, {state: 'freeze', action: true}],
        boom    : [198, 198,  5]
};

var mouse = {x : 0, y : 0};
var pointer = {x : 0, y : 0};
var oldPointer = {x : 0, y : 0};


function keydownControls(e) {

    if (e.keyCode === keyboard.f) {
        isCameraFirstPerson = !isCameraFirstPerson;

        player.camera.distance = isCameraFirstPerson ?
                                 .5 : thirdPersonCameraDistance;

    }
    else if (e.keyCode === keyboard.c) {
        if (player.model.state === 'stand') changeMotion('crstand');
        else if (player.model.state === 'crstand') changeMotion('stand');
    }
    else if (e.keyCode === keyboard.z || e.keyCode === keyboard.up) {
        moveState.front = true;
        moveState.Backwards = false;
    }
    else if (e.keyCode === keyboard.s || e.keyCode === keyboard.down) {
        moveState.Backwards = true;
        moveState.front = false;
    }
    else if (e.keyCode === keyboard.q || e.keyCode === keyboard.left) {
        moveState.left = true;
        moveState.right = false;
    }
    else if (e.keyCode === keyboard.d || e.keyCode === keyboard.right) {
        moveState.right = true;
        moveState.left = false;
    }
    else return;

    //document.title = e.keyCode;    

    if (!moveState.moving) {
        if (player.model.state === 'stand') changeMotion('run');
        if (player.model.state === 'crstand') changeMotion('crwalk');
        
        moveState.moving = true;
        move();
        timer = setInterval(function(){move();}, 1000 / 60);
    }


}


function keyupControls(e) {

    if (e.keyCode === keyboard.z || e.keyCode === keyboard.up) moveState.front = false;
    else if (e.keyCode === keyboard.s || e.keyCode === keyboard.down) moveState.Backwards = false;
    else if (e.keyCode === keyboard.q || e.keyCode === keyboard.left) moveState.left = false;
    else if (e.keyCode === keyboard.d || e.keyCode === keyboard.right) moveState.right = false;

    if (!moveState.front && !moveState.Backwards && !moveState.left && !moveState.right) {
        changeMotion(player.model.state);
        moveState.moving = false;
        clearInterval(timer);
    }
}

/**
 * @param {mouseEvent} e
 */
function mousemoveControls(e) {

    mouse = {x: e.clientX - getElementPosition(renderer.domElement).left,
             y: e.clientY - getElementPosition(renderer.domElement).top};

    pointer.x =   (mouse.x / renderer.domElement.width) * 2 - 1;
    pointer.y = - (mouse.y / renderer.domElement.height) * 2 + 1;

    player.camera.x += (oldPointer.x - pointer.x) * player.camera.speed;
    player.camera.y += (oldPointer.y - pointer.y) * player.camera.speed;

    if (player.camera.y > 160) player.camera.y = 160; 
    else if (player.camera.y < -15) player.camera.y = -15;
        
    moveState.angle = (player.camera.x / 2) % 360;
        
    oldPointer.x = pointer.x;
    oldPointer.y = pointer.y;

}

function move() {

    if (player.model.motion !== 'run' &&
        player.model.state === 'stand') changeMotion('run');
    else if (player.model.motion !== 'crwalk' &&
        player.model.state === 'crstand') changeMotion('crwalk');

    var speed = moveState.speed;
    if (player.model.state === 'crstand') speed *= .5;
    if (player.model.state === 'freeze') speed = 0;
    
    var direction = moveState.angle;

    if (moveState.front) {
        if (moveState.left) direction = 45;
        else if (moveState.right) direction = 315;
        else direction = 0;
    }
    else if (moveState.Backwards) {
        if (moveState.left) direction = 135;
        else if (moveState.right) direction = 225;
        else direction = 180;
    }
    else {
        if (moveState.left) direction = 90;
        else if (moveState.right) direction = 270;
        else direction = 0;
    }
    
    player.model.objects.rotation.y = direction * deg2rad;
    player.position.x -= Math.sin(direction * deg2rad) * speed;
    player.position.z -= Math.cos(direction * deg2rad) * speed;
}

function changeMotion(motion) {

    player.model.motion = motion;
    player.model.state = md2frames[motion][3].state;
    
    var animMin = md2frames[motion][0];
    var animMax = md2frames[motion][1];
    var animFps = md2frames[motion][2];

    md2meshBody.time = 0;
    md2meshBody.duration = 1000 * (( animMax - animMin ) / animFps);
    md2meshBody.setFrameRange(animMin, animMax);
}

function animate() {
    requestAnimationFrame( animate );
    
    player.model.objects.position.x = player.position.x;
    player.model.objects.position.y = player.position.y;
    player.model.objects.position.z = player.position.z;
    
    // camera rotate x
    camera.position.x = player.position.x + player.camera.distance * Math.sin(player.camera.x * deg2rad/2);
    camera.position.z = player.position.z + player.camera.distance * Math.cos(player.camera.x * deg2rad/2);
    
    //camera rotate y

    //camera.position.x = player.position.x + player.camera.distance * Math.cos( (player.camera.y) * Math.PI / 360 );
    camera.position.y = player.position.y + player.camera.distance * Math.sin(player.camera.y * deg2rad/2);
    //camera.position.z = player.position.z + player.camera.distance * Math.cos( (player.camera.y) * Math.PI / 360 );
    
    camera.position.y += 1;
    
    var vec3 = new THREE.Vector3( player.position.x,  player.position.y + 1,  player.position.z)
    camera.lookAt( vec3 );
    
    // model animation
    var delta = clock.getDelta();
    if (md2meshBody) {
        var isEndFleame = (md2frames[player.model.motion][1] === md2meshBody.currentKeyframe);
        var isAction = md2frames[player.model.motion][3].action;
        
        if(!isAction || (isAction && !isEndFleame)){
            md2meshBody.updateAnimation(1000 * delta);
        }else if(/freeze/.test(md2frames[player.model.motion][3].state)){
            //dead...
        }else{
            changeMotion(player.model.state);
        }
    }
    
    renderer.render( scene, camera );
}


var getElementPosition = function(element) {
    var top = left = 0;
    do {
        top  += element.offsetTop  || 0;
        left += element.offsetLeft || 0;
        element =  element.offsetParent;
    }
    while (element);
    return {top: top, left: left};
}


// When html is fully loaded :
window.addEventListener('DOMContentLoaded', function(){

    width = window.innerWidth;
    height = window.innerHeight;

    clock = new THREE.Clock();

    scene = new THREE.Scene();

    // Initialize renderer engine
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(width, height);

    // Activate shadows
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    
    // Shadows options :
    // renderer.shadowCameraNear = camera.near;
    // renderer.shadowCameraFar = camera.far;
    // renderer.shadowCameraFov = 50;
    // renderer.shadowMapBias = 0.0039;
    // renderer.shadowMapDarkness = 0.5;
    // renderer.shadowMapWidth = 500;
    // renderer.shadowMapHeight = 500; 

    document.body.appendChild(renderer.domElement);

    // Create the blue sky
    scene.fog = new THREE.FogExp2(0x9999ff, 0.01);
    var ambientLight = new THREE.AmbientLight(0x202020);
    scene.add(ambientLight);

    // Create the ground (grass field)
    var planeGeometry = new THREE.PlaneGeometry(1000, 1000);

    var planeMaterial = new THREE.MeshLambertMaterial({
        map: THREE.ImageUtils.loadTexture('images/grass.png'),
        color: 0xffffff});

    planeMaterial.map.repeat.x = 300;
    planeMaterial.map.repeat.y = 300;
    planeMaterial.map.wrapS = THREE.RepeatWrapping;
    planeMaterial.map.wrapT = THREE.RepeatWrapping;
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.castShadow = false;
    plane.receiveShadow = true;
    scene.add(plane);

    // Initialize the camera
    camera = new THREE.PerspectiveCamera(40, width / height, 1, 1000);
    scene.add(camera);
    
    // Insert the player
    scene.add(player.model.objects);

    // Create sunlight
    var sunlight = new THREE.DirectionalLight(0xfffffa, 1.5);
    sunlight.position.set(1, 50, 1).normalize();
    sunlight.castShadow = true;
    scene.add(sunlight);
    
    animate();
    
    // Add cubes
    var meshArray = [];
    var geometry = new THREE.CubeGeometry( 1, 1, 1 );
    for( var i = 0; i < 100; i++ ){

        meshArray[i] = new THREE.Mesh(geometry,
                                      new THREE.MeshLambertMaterial({
                                        color: 0xffffff * Math.random()}));

        meshArray[i].position.x = i % 2 * 5 - 2.5;
        meshArray[i].position.y = .5;
        meshArray[i].position.z = -1 * i * 4;
        meshArray[i].castShadow = true;
        meshArray[i].receiveShadow = true;
        scene.add(meshArray[i]);
    }

/**
 * load md2 model
 */

    material = new THREE.MeshLambertMaterial({
        map: THREE.ImageUtils.loadTexture('images/1.png'),
        ambient: 0x999999,
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 25,
        morphTargets: true});

    loader = new THREE.JSONLoader();

    loader.load( 'js/droid.js', function( geometry ) {
        md2meshBody = new THREE.MorphAnimMesh( geometry, material );
        md2meshBody.rotation.y = -Math.PI / 2;
        md2meshBody.scale.set(.02, .02, .02);
        md2meshBody.position.y = .5;
        md2meshBody.castShadow = true;
        md2meshBody.receiveShadow = true;
        changeMotion('stand');
        player.model.objects.add( md2meshBody );
        console.log(player.model.objects)
    } );

document.addEventListener('keydown', keydownControls);
document.addEventListener('keyup', keyupControls);
document.addEventListener('mousemove', mousemoveControls);        

}, false);</script>
</head><body></body></html>